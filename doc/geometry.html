<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>jefpy.geometry API documentation</title>
<meta name="description" content="Convenience module for sampling purposes. Transformations to curvilinear
coordinates are also available." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jefpy.geometry</code></h1>
</header>
<section id="section-intro">
<p>Convenience module for sampling purposes. Transformations to curvilinear
coordinates are also available.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Convenience module for sampling purposes. Transformations to curvilinear
coordinates are also available.
&#34;&#34;&#34;

from jefpy.utils import default, is_iter
from jefpy.math import dot, norm
import numpy as np


class Surface:
    &#34;&#34;&#34;
    TODO refactor using inheritance
    Class for creating meshed surfaces. The class methods set self.XYZ.
    &#34;&#34;&#34;

    def __init__(self, u=None, v=None):
        &#34;&#34;&#34;
        Object initialization only makes sense from a class method, \n
        which determines the type of surface. \n
        u: (N) array, spans the first dimension of the surface. \n
        v: (M) array, spans the second dimension of the surface. \n
        U: (N x M) array, meshgrid. \n
        V: (N x M) array, meshgrid. \n
        XYZ: (N x M x 3) array, cartesian coordinates of the surface.
        &#34;&#34;&#34;
        self.u = default(u, np.linspace(0.0, 1.0, 10))
        self.v = default(v, np.linspace(0.0, 1.0, 10))
        self.U, self.V = np.meshgrid(self.u, self.v, indexing=&#39;ij&#39;)
        self.UV = np.stack((self.U, self.V), axis=-1)
        self.XYZ = np.empty((len(self.u), len(self.v), 3))

    @classmethod
    def cartesian(cls, x=None, y=None, z=None):
        &#34;&#34;&#34;
        Creates a surface that is in the xy, yz, or xz plane. What plane
        is created is determined by what input argument is a float and which
        ones are iterable. Two have to be iterable and one has to be a float
        for a valid surface to be created.
        &#34;&#34;&#34;
        x = default(x, np.linspace(0.0, 1.0, 10))
        y = default(y, np.linspace(0.0, 1.0, 10))
        z = default(z, 0.0)
        # Some tricks to determine if uv = xy, yz, or xz

        axes = np.array((is_iter(x), is_iter(y), is_iter(z)))
        u, v = np.array((x, y, z), dtype=object)[axes]
        w = np.array((x, y, z), dtype=object)[~axes]
        self = cls(u=u, v=v)
        self.XYZ[:, :, axes] = np.stack((self.U, self.V), axis=-1)
        self.XYZ[:, :, ~axes] = (w * np.ones_like(self.U))[:, :, np.newaxis]
        return self

    @classmethod
    def cylinder(cls, radius=1.0, phi=None, z=None, axis=&#39;z&#39;):
        &#34;&#34;&#34;
        Creates a surface that is the outside of a cylinder. By default the
        cylinder points in the z-direction, but it can be oriented along the
        x or the y axis.

        :param radius: float, single value setting the cylinder radius
        :param phi: 1D-array, span of angles
        :param z: 1D-array, span of the &#39;z&#39; axis.
        :param axis: str, sets the orientation (&#39;z&#39;-axis) of the cylinder
        &#34;&#34;&#34;
        phi = default(phi, np.linspace(0.0, 2*np.pi, 10))
        z = default(z, np.linspace(0.0, 1.0, 10))
        surf = cls(u=phi, v=z)
        i, j, k = {&#39;z&#39;: (0, 1, 2), &#39;y&#39;: (2, 0, 1), &#39;x&#39;: (1, 2, 0)}[axis]
        surf.XYZ[..., i] = radius * np.cos(surf.U)
        surf.XYZ[..., j] = radius * np.sin(surf.U)
        surf.XYZ[..., k] = surf.V
        return surf


    @classmethod
    def sphere(cls, radius=1.0, theta=None, phi=None, center=(0, 0, 0)):
        &#34;&#34;&#34;
        Creates a spherical surface located anywhere in space.

        :param radius: flaot, single vale setting the sphere radius.
        :param theta: 1D-array, angle w.r.t the z-axis.
        :param phi: 1D-array, angle in the xy plane.
        :param center: (3) array, Location in space of the center of the sphere
        &#34;&#34;&#34;
        phi = default(phi, np.linspace(0.0, 2*np.pi, 10))
        theta = default(theta, np.linspace(0.0, np.pi, 10))
        self = cls(u=theta, v=phi)
        self.XYZ[..., 0] = radius * np.sin(self.U) * np.cos(self.V)
        self.XYZ[..., 1] = radius * np.sin(self.U) * np.sin(self.V)
        self.XYZ[..., 2] = radius * np.cos(self.U)
        self.XYZ += np.array(center)
        return self

    def flat_coords(self):
        X, Y, Z = self.split_mesh()
        return X.flatten(), Y.flatten(), Z.flatten()

    def split_mesh(self):
        X, Y, Z = np.split(self.XYZ, 3, axis=2)
        return X, Y, Z


class Volume:
    &#34;&#34;&#34;
    Class for creating meshed volumes. The class methods set self.XYZ.
    &#34;&#34;&#34;

    def __init__(self, u=None, v=None, w=None):
        &#34;&#34;&#34;
        Object initialization only makes sense from a class method,
        which determines the type of surface.

        :param u: (N) array, spans the first dimension of the volume.
        :param v: (M) array, spans the first dimension of the volume.
        :param w: (L) array, spans the first dimension of the volume.
        &#34;&#34;&#34;
        self.u = default(u, np.linspace(0.0, 1.0, 10))
        self.v = default(v, np.linspace(0.0, 1.0, 10))
        self.w = default(w, np.linspace(0.0, 1.0, 10))
        self.X, self.Y, self.Z = \
            np.meshgrid(self.u, self.v, self.w)
        self.XYZ = np.empty((len(self.u), len(self.v), 3))

    @classmethod
    def cartesian(cls, x=None, y=None, z=None):
        &#34;&#34;&#34;
        Creates a cartesian meshed rectangle.
        :param x: 1D-array, span of x.
        :param y: 1D-array, span of y.
        :param z: 1D-array, span of z.
        &#34;&#34;&#34;
        self = cls(u=x, v=y, w=z)
        self.XYZ = np.stack((self.X, self.Y, self.Z), axis=-1)
        return self


def to_spherical(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to spherical coordinates. r and
    F can have any shape, as long as the last dimension represents one
    particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in spherical coordinates.
    &#34;&#34;&#34;
    x, y, z = r[..., 0], r[..., 1], r[..., 2]
    l = norm(r)
    l_xy = np.sqrt(x ** 2 + y ** 2)

    # unit vectors
    rho = r / l[..., np.newaxis]
    theta_x = z * x / l / l_xy
    theta_y = z * y / l / l_xy
    theta_z = - l_xy / l
    theta = np.stack((theta_x, theta_y, theta_z), axis=-1)
    phi = np.stack((-y / l, x / l, x*0), axis=-1)

    return np.stack((dot(F, rho), dot(F, theta), dot(F, phi)), axis=-1)



def _to_cylindrical(r, F, axis=&#39;z&#39;):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates. r and
    F can have any shape, as long as the last dimension represents one
    particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :param axis: str, pecify the orientation of the cylinder.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    i, j, k = {&#39;z&#39;: (0, 1, 2), &#39;y&#39;: (2, 0, 1), &#39;x&#39;: (1, 2, 0)}[axis]
    l = np.sqrt(r[..., i] ** 2 + r[..., j] ** 2)

    # unit vectors
    zero = np.zeros_like(l)
    rho = np.stack((r[..., i] / l, r[..., j] / l, zero), axis=-1)
    rho = rho[..., (i, j, k)]
    theta = np.stack((-r[..., j] / l, r[..., i] / l, zero), axis=-1)
    theta = theta[..., (i, j, k)]

    return np.stack((dot(F, rho), dot(F, theta), F[..., k]), axis=-1)


def to_cylindrical_x(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates,
    with the cylinder oriented around the x-axis. r and  F can have any shape,
    as long as the last dimension represents one particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    return _to_cylindrical(r, F, &#39;x&#39;)


def to_cylindrical_y(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates,
    with the cylinder oriented around the y-axis. r and  F can have any shape,
    as long as the last dimension represents one particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    return _to_cylindrical(r, F, &#39;y&#39;)


def to_cylindrical_z(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates,
    with the cylinder oriented around the z-axis. r and  F can have any shape,
    as long as the last dimension represents one particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    return _to_cylindrical(r, F, &#39;z&#39;)


def to_cylindrical(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates, 
    with the cylinder oriented around the z-axis. r and F can have any shape, 
    as long as the last dimension represents one particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    return _to_cylindrical(r, F, &#39;z&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="jefpy.geometry.to_cylindrical"><code class="name flex">
<span>def <span class="ident">to_cylindrical</span></span>(<span>r, F)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms a vector field from cartesian to cylindrical coordinates,
with the cylinder oriented around the z-axis. r and F can have any shape,
as long as the last dimension represents one particular 3D vector.
:param r: (&hellip;, 3) array, cartesian positions.
:param F: (&hellip;, 3) array, cartesian vector field.
:return: (&hellip;, 3) array, vector field in cylindrical coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_cylindrical(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates, 
    with the cylinder oriented around the z-axis. r and F can have any shape, 
    as long as the last dimension represents one particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    return _to_cylindrical(r, F, &#39;z&#39;)</code></pre>
</details>
</dd>
<dt id="jefpy.geometry.to_cylindrical_x"><code class="name flex">
<span>def <span class="ident">to_cylindrical_x</span></span>(<span>r, F)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms a vector field from cartesian to cylindrical coordinates,
with the cylinder oriented around the x-axis. r and
F can have any shape,
as long as the last dimension represents one particular 3D vector.
:param r: (&hellip;, 3) array, cartesian positions.
:param F: (&hellip;, 3) array, cartesian vector field.
:return: (&hellip;, 3) array, vector field in cylindrical coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_cylindrical_x(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates,
    with the cylinder oriented around the x-axis. r and  F can have any shape,
    as long as the last dimension represents one particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    return _to_cylindrical(r, F, &#39;x&#39;)</code></pre>
</details>
</dd>
<dt id="jefpy.geometry.to_cylindrical_y"><code class="name flex">
<span>def <span class="ident">to_cylindrical_y</span></span>(<span>r, F)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms a vector field from cartesian to cylindrical coordinates,
with the cylinder oriented around the y-axis. r and
F can have any shape,
as long as the last dimension represents one particular 3D vector.
:param r: (&hellip;, 3) array, cartesian positions.
:param F: (&hellip;, 3) array, cartesian vector field.
:return: (&hellip;, 3) array, vector field in cylindrical coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_cylindrical_y(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates,
    with the cylinder oriented around the y-axis. r and  F can have any shape,
    as long as the last dimension represents one particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    return _to_cylindrical(r, F, &#39;y&#39;)</code></pre>
</details>
</dd>
<dt id="jefpy.geometry.to_cylindrical_z"><code class="name flex">
<span>def <span class="ident">to_cylindrical_z</span></span>(<span>r, F)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms a vector field from cartesian to cylindrical coordinates,
with the cylinder oriented around the z-axis. r and
F can have any shape,
as long as the last dimension represents one particular 3D vector.
:param r: (&hellip;, 3) array, cartesian positions.
:param F: (&hellip;, 3) array, cartesian vector field.
:return: (&hellip;, 3) array, vector field in cylindrical coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_cylindrical_z(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to cylindrical coordinates,
    with the cylinder oriented around the z-axis. r and  F can have any shape,
    as long as the last dimension represents one particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in cylindrical coordinates.
    &#34;&#34;&#34;
    return _to_cylindrical(r, F, &#39;z&#39;)</code></pre>
</details>
</dd>
<dt id="jefpy.geometry.to_spherical"><code class="name flex">
<span>def <span class="ident">to_spherical</span></span>(<span>r, F)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms a vector field from cartesian to spherical coordinates. r and
F can have any shape, as long as the last dimension represents one
particular 3D vector.
:param r: (&hellip;, 3) array, cartesian positions.
:param F: (&hellip;, 3) array, cartesian vector field.
:return: (&hellip;, 3) array, vector field in spherical coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_spherical(r, F):
    &#34;&#34;&#34;
    Transforms a vector field from cartesian to spherical coordinates. r and
    F can have any shape, as long as the last dimension represents one
    particular 3D vector.
    :param r: (..., 3) array, cartesian positions.
    :param F: (..., 3) array, cartesian vector field.
    :return: (..., 3) array, vector field in spherical coordinates.
    &#34;&#34;&#34;
    x, y, z = r[..., 0], r[..., 1], r[..., 2]
    l = norm(r)
    l_xy = np.sqrt(x ** 2 + y ** 2)

    # unit vectors
    rho = r / l[..., np.newaxis]
    theta_x = z * x / l / l_xy
    theta_y = z * y / l / l_xy
    theta_z = - l_xy / l
    theta = np.stack((theta_x, theta_y, theta_z), axis=-1)
    phi = np.stack((-y / l, x / l, x*0), axis=-1)

    return np.stack((dot(F, rho), dot(F, theta), dot(F, phi)), axis=-1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jefpy.geometry.Surface"><code class="flex name class">
<span>class <span class="ident">Surface</span></span>
<span>(</span><span>u=None, v=None)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO refactor using inheritance
Class for creating meshed surfaces. The class methods set self.XYZ.</p>
<p>Object initialization only makes sense from a class method, </p>
<p>which determines the type of surface. </p>
<p>u: (N) array, spans the first dimension of the surface. </p>
<p>v: (M) array, spans the second dimension of the surface. </p>
<p>U: (N x M) array, meshgrid. </p>
<p>V: (N x M) array, meshgrid. </p>
<p>XYZ: (N x M x 3) array, cartesian coordinates of the surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Surface:
    &#34;&#34;&#34;
    TODO refactor using inheritance
    Class for creating meshed surfaces. The class methods set self.XYZ.
    &#34;&#34;&#34;

    def __init__(self, u=None, v=None):
        &#34;&#34;&#34;
        Object initialization only makes sense from a class method, \n
        which determines the type of surface. \n
        u: (N) array, spans the first dimension of the surface. \n
        v: (M) array, spans the second dimension of the surface. \n
        U: (N x M) array, meshgrid. \n
        V: (N x M) array, meshgrid. \n
        XYZ: (N x M x 3) array, cartesian coordinates of the surface.
        &#34;&#34;&#34;
        self.u = default(u, np.linspace(0.0, 1.0, 10))
        self.v = default(v, np.linspace(0.0, 1.0, 10))
        self.U, self.V = np.meshgrid(self.u, self.v, indexing=&#39;ij&#39;)
        self.UV = np.stack((self.U, self.V), axis=-1)
        self.XYZ = np.empty((len(self.u), len(self.v), 3))

    @classmethod
    def cartesian(cls, x=None, y=None, z=None):
        &#34;&#34;&#34;
        Creates a surface that is in the xy, yz, or xz plane. What plane
        is created is determined by what input argument is a float and which
        ones are iterable. Two have to be iterable and one has to be a float
        for a valid surface to be created.
        &#34;&#34;&#34;
        x = default(x, np.linspace(0.0, 1.0, 10))
        y = default(y, np.linspace(0.0, 1.0, 10))
        z = default(z, 0.0)
        # Some tricks to determine if uv = xy, yz, or xz

        axes = np.array((is_iter(x), is_iter(y), is_iter(z)))
        u, v = np.array((x, y, z), dtype=object)[axes]
        w = np.array((x, y, z), dtype=object)[~axes]
        self = cls(u=u, v=v)
        self.XYZ[:, :, axes] = np.stack((self.U, self.V), axis=-1)
        self.XYZ[:, :, ~axes] = (w * np.ones_like(self.U))[:, :, np.newaxis]
        return self

    @classmethod
    def cylinder(cls, radius=1.0, phi=None, z=None, axis=&#39;z&#39;):
        &#34;&#34;&#34;
        Creates a surface that is the outside of a cylinder. By default the
        cylinder points in the z-direction, but it can be oriented along the
        x or the y axis.

        :param radius: float, single value setting the cylinder radius
        :param phi: 1D-array, span of angles
        :param z: 1D-array, span of the &#39;z&#39; axis.
        :param axis: str, sets the orientation (&#39;z&#39;-axis) of the cylinder
        &#34;&#34;&#34;
        phi = default(phi, np.linspace(0.0, 2*np.pi, 10))
        z = default(z, np.linspace(0.0, 1.0, 10))
        surf = cls(u=phi, v=z)
        i, j, k = {&#39;z&#39;: (0, 1, 2), &#39;y&#39;: (2, 0, 1), &#39;x&#39;: (1, 2, 0)}[axis]
        surf.XYZ[..., i] = radius * np.cos(surf.U)
        surf.XYZ[..., j] = radius * np.sin(surf.U)
        surf.XYZ[..., k] = surf.V
        return surf


    @classmethod
    def sphere(cls, radius=1.0, theta=None, phi=None, center=(0, 0, 0)):
        &#34;&#34;&#34;
        Creates a spherical surface located anywhere in space.

        :param radius: flaot, single vale setting the sphere radius.
        :param theta: 1D-array, angle w.r.t the z-axis.
        :param phi: 1D-array, angle in the xy plane.
        :param center: (3) array, Location in space of the center of the sphere
        &#34;&#34;&#34;
        phi = default(phi, np.linspace(0.0, 2*np.pi, 10))
        theta = default(theta, np.linspace(0.0, np.pi, 10))
        self = cls(u=theta, v=phi)
        self.XYZ[..., 0] = radius * np.sin(self.U) * np.cos(self.V)
        self.XYZ[..., 1] = radius * np.sin(self.U) * np.sin(self.V)
        self.XYZ[..., 2] = radius * np.cos(self.U)
        self.XYZ += np.array(center)
        return self

    def flat_coords(self):
        X, Y, Z = self.split_mesh()
        return X.flatten(), Y.flatten(), Z.flatten()

    def split_mesh(self):
        X, Y, Z = np.split(self.XYZ, 3, axis=2)
        return X, Y, Z</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="jefpy.geometry.Surface.cartesian"><code class="name flex">
<span>def <span class="ident">cartesian</span></span>(<span>x=None, y=None, z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a surface that is in the xy, yz, or xz plane. What plane
is created is determined by what input argument is a float and which
ones are iterable. Two have to be iterable and one has to be a float
for a valid surface to be created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cartesian(cls, x=None, y=None, z=None):
    &#34;&#34;&#34;
    Creates a surface that is in the xy, yz, or xz plane. What plane
    is created is determined by what input argument is a float and which
    ones are iterable. Two have to be iterable and one has to be a float
    for a valid surface to be created.
    &#34;&#34;&#34;
    x = default(x, np.linspace(0.0, 1.0, 10))
    y = default(y, np.linspace(0.0, 1.0, 10))
    z = default(z, 0.0)
    # Some tricks to determine if uv = xy, yz, or xz

    axes = np.array((is_iter(x), is_iter(y), is_iter(z)))
    u, v = np.array((x, y, z), dtype=object)[axes]
    w = np.array((x, y, z), dtype=object)[~axes]
    self = cls(u=u, v=v)
    self.XYZ[:, :, axes] = np.stack((self.U, self.V), axis=-1)
    self.XYZ[:, :, ~axes] = (w * np.ones_like(self.U))[:, :, np.newaxis]
    return self</code></pre>
</details>
</dd>
<dt id="jefpy.geometry.Surface.cylinder"><code class="name flex">
<span>def <span class="ident">cylinder</span></span>(<span>radius=1.0, phi=None, z=None, axis='z')</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a surface that is the outside of a cylinder. By default the
cylinder points in the z-direction, but it can be oriented along the
x or the y axis.</p>
<p>:param radius: float, single value setting the cylinder radius
:param phi: 1D-array, span of angles
:param z: 1D-array, span of the 'z' axis.
:param axis: str, sets the orientation ('z'-axis) of the cylinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cylinder(cls, radius=1.0, phi=None, z=None, axis=&#39;z&#39;):
    &#34;&#34;&#34;
    Creates a surface that is the outside of a cylinder. By default the
    cylinder points in the z-direction, but it can be oriented along the
    x or the y axis.

    :param radius: float, single value setting the cylinder radius
    :param phi: 1D-array, span of angles
    :param z: 1D-array, span of the &#39;z&#39; axis.
    :param axis: str, sets the orientation (&#39;z&#39;-axis) of the cylinder
    &#34;&#34;&#34;
    phi = default(phi, np.linspace(0.0, 2*np.pi, 10))
    z = default(z, np.linspace(0.0, 1.0, 10))
    surf = cls(u=phi, v=z)
    i, j, k = {&#39;z&#39;: (0, 1, 2), &#39;y&#39;: (2, 0, 1), &#39;x&#39;: (1, 2, 0)}[axis]
    surf.XYZ[..., i] = radius * np.cos(surf.U)
    surf.XYZ[..., j] = radius * np.sin(surf.U)
    surf.XYZ[..., k] = surf.V
    return surf</code></pre>
</details>
</dd>
<dt id="jefpy.geometry.Surface.sphere"><code class="name flex">
<span>def <span class="ident">sphere</span></span>(<span>radius=1.0, theta=None, phi=None, center=(0, 0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a spherical surface located anywhere in space.</p>
<p>:param radius: flaot, single vale setting the sphere radius.
:param theta: 1D-array, angle w.r.t the z-axis.
:param phi: 1D-array, angle in the xy plane.
:param center: (3) array, Location in space of the center of the sphere</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def sphere(cls, radius=1.0, theta=None, phi=None, center=(0, 0, 0)):
    &#34;&#34;&#34;
    Creates a spherical surface located anywhere in space.

    :param radius: flaot, single vale setting the sphere radius.
    :param theta: 1D-array, angle w.r.t the z-axis.
    :param phi: 1D-array, angle in the xy plane.
    :param center: (3) array, Location in space of the center of the sphere
    &#34;&#34;&#34;
    phi = default(phi, np.linspace(0.0, 2*np.pi, 10))
    theta = default(theta, np.linspace(0.0, np.pi, 10))
    self = cls(u=theta, v=phi)
    self.XYZ[..., 0] = radius * np.sin(self.U) * np.cos(self.V)
    self.XYZ[..., 1] = radius * np.sin(self.U) * np.sin(self.V)
    self.XYZ[..., 2] = radius * np.cos(self.U)
    self.XYZ += np.array(center)
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jefpy.geometry.Surface.flat_coords"><code class="name flex">
<span>def <span class="ident">flat_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flat_coords(self):
    X, Y, Z = self.split_mesh()
    return X.flatten(), Y.flatten(), Z.flatten()</code></pre>
</details>
</dd>
<dt id="jefpy.geometry.Surface.split_mesh"><code class="name flex">
<span>def <span class="ident">split_mesh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_mesh(self):
    X, Y, Z = np.split(self.XYZ, 3, axis=2)
    return X, Y, Z</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="jefpy.geometry.Volume"><code class="flex name class">
<span>class <span class="ident">Volume</span></span>
<span>(</span><span>u=None, v=None, w=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for creating meshed volumes. The class methods set self.XYZ.</p>
<p>Object initialization only makes sense from a class method,
which determines the type of surface.</p>
<p>:param u: (N) array, spans the first dimension of the volume.
:param v: (M) array, spans the first dimension of the volume.
:param w: (L) array, spans the first dimension of the volume.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Volume:
    &#34;&#34;&#34;
    Class for creating meshed volumes. The class methods set self.XYZ.
    &#34;&#34;&#34;

    def __init__(self, u=None, v=None, w=None):
        &#34;&#34;&#34;
        Object initialization only makes sense from a class method,
        which determines the type of surface.

        :param u: (N) array, spans the first dimension of the volume.
        :param v: (M) array, spans the first dimension of the volume.
        :param w: (L) array, spans the first dimension of the volume.
        &#34;&#34;&#34;
        self.u = default(u, np.linspace(0.0, 1.0, 10))
        self.v = default(v, np.linspace(0.0, 1.0, 10))
        self.w = default(w, np.linspace(0.0, 1.0, 10))
        self.X, self.Y, self.Z = \
            np.meshgrid(self.u, self.v, self.w)
        self.XYZ = np.empty((len(self.u), len(self.v), 3))

    @classmethod
    def cartesian(cls, x=None, y=None, z=None):
        &#34;&#34;&#34;
        Creates a cartesian meshed rectangle.
        :param x: 1D-array, span of x.
        :param y: 1D-array, span of y.
        :param z: 1D-array, span of z.
        &#34;&#34;&#34;
        self = cls(u=x, v=y, w=z)
        self.XYZ = np.stack((self.X, self.Y, self.Z), axis=-1)
        return self</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="jefpy.geometry.Volume.cartesian"><code class="name flex">
<span>def <span class="ident">cartesian</span></span>(<span>x=None, y=None, z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a cartesian meshed rectangle.
:param x: 1D-array, span of x.
:param y: 1D-array, span of y.
:param z: 1D-array, span of z.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cartesian(cls, x=None, y=None, z=None):
    &#34;&#34;&#34;
    Creates a cartesian meshed rectangle.
    :param x: 1D-array, span of x.
    :param y: 1D-array, span of y.
    :param z: 1D-array, span of z.
    &#34;&#34;&#34;
    self = cls(u=x, v=y, w=z)
    self.XYZ = np.stack((self.X, self.Y, self.Z), axis=-1)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jefpy" href="index.html">jefpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="jefpy.geometry.to_cylindrical" href="#jefpy.geometry.to_cylindrical">to_cylindrical</a></code></li>
<li><code><a title="jefpy.geometry.to_cylindrical_x" href="#jefpy.geometry.to_cylindrical_x">to_cylindrical_x</a></code></li>
<li><code><a title="jefpy.geometry.to_cylindrical_y" href="#jefpy.geometry.to_cylindrical_y">to_cylindrical_y</a></code></li>
<li><code><a title="jefpy.geometry.to_cylindrical_z" href="#jefpy.geometry.to_cylindrical_z">to_cylindrical_z</a></code></li>
<li><code><a title="jefpy.geometry.to_spherical" href="#jefpy.geometry.to_spherical">to_spherical</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jefpy.geometry.Surface" href="#jefpy.geometry.Surface">Surface</a></code></h4>
<ul class="">
<li><code><a title="jefpy.geometry.Surface.cartesian" href="#jefpy.geometry.Surface.cartesian">cartesian</a></code></li>
<li><code><a title="jefpy.geometry.Surface.cylinder" href="#jefpy.geometry.Surface.cylinder">cylinder</a></code></li>
<li><code><a title="jefpy.geometry.Surface.flat_coords" href="#jefpy.geometry.Surface.flat_coords">flat_coords</a></code></li>
<li><code><a title="jefpy.geometry.Surface.sphere" href="#jefpy.geometry.Surface.sphere">sphere</a></code></li>
<li><code><a title="jefpy.geometry.Surface.split_mesh" href="#jefpy.geometry.Surface.split_mesh">split_mesh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jefpy.geometry.Volume" href="#jefpy.geometry.Volume">Volume</a></code></h4>
<ul class="">
<li><code><a title="jefpy.geometry.Volume.cartesian" href="#jefpy.geometry.Volume.cartesian">cartesian</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>